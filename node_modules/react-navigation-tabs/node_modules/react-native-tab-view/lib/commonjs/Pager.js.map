{"version":3,"sources":["Pager.tsx"],"names":["Clock","Animated","Value","onChange","abs","add","and","block","call","ceil","clockRunning","cond","divide","eq","event","floor","greaterThan","lessThan","max","min","multiply","neq","or","not","round","set","spring","startClock","stopClock","sub","timing","TRUE","FALSE","NOOP","UNSET","DIRECTION_LEFT","DIRECTION_RIGHT","SWIPE_DISTANCE_MINIMUM","SWIPE_DISTANCE_MULTIPLIER","SWIPE_VELOCITY_THRESHOLD_DEFAULT","SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","TIMING_CONFIG","duration","easing","Easing","out","cubic","Pager","clock","velocityX","gestureX","gestureState","State","UNDETERMINED","offsetX","progress","props","navigationState","index","layout","width","nextIndex","lastEnteredIndex","isSwiping","isSwipeGesture","routesLength","routes","length","layoutWidth","swipeDistanceThreshold","swipeVelocityThreshold","position","springConfig","undefined","timingConfig","initialVelocityForSpring","currentIndexValue","pendingIndexValue","enterListeners","jumpToIndex","setValue","jumpTo","key","findIndex","route","onIndexChange","addListener","type","listener","push","removeListener","indexOf","splice","handleEnteredIndexChange","value","Math","forEach","transitionTo","toValue","frameTime","state","time","finished","I18nManager","isRTL","velocity","handleGestureEvent","nativeEvent","translationX","translateX","forceUpdate","keyboardDismissMode","onSwipeStart","onSwipeEnd","Keyboard","dismiss","ACTIVE","getTranslateX","prevProps","swipeEnabled","children","removeClippedSubviews","gestureHandlerProps","render","styles","container","transform","React","Component","defaultProps","StyleSheet","create","flex","flexDirection"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, Keyboard, I18nManager } from 'react-native';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\nimport Animated, { Easing } from 'react-native-reanimated';\nimport memoize from './memoize';\n\nimport {\n  Layout,\n  NavigationState,\n  Route,\n  Listener,\n  PagerCommonProps,\n  EventEmitterProps,\n} from './types';\n\ntype Binary = 0 | 1;\n\ntype Props<T extends Route> = PagerCommonProps & {\n  onIndexChange: (index: number) => void;\n  navigationState: NavigationState<T>;\n  layout: Layout;\n  // Clip unfocused views to improve memory usage\n  // Don't enable this on iOS where this is buggy and views don't re-appear\n  removeClippedSubviews?: boolean;\n  children: (\n    props: EventEmitterProps & {\n      // Animated value which represents the state of current index\n      // It can include fractional digits as it represents the intermediate value\n      position: Animated.Node<number>;\n      // Function to actually render the content of the pager\n      // The parent component takes care of rendering\n      render: (children: React.ReactNode) => React.ReactNode;\n      // Callback to call when switching the tab\n      // The tab switch animation is performed even if the index in state is unchanged\n      jumpTo: (key: string) => void;\n    }\n  ) => React.ReactNode;\n  gestureHandlerProps: React.ComponentProps<typeof PanGestureHandler>;\n};\n\nconst {\n  Clock,\n  Value,\n  onChange,\n  abs,\n  add,\n  and,\n  block,\n  call,\n  ceil,\n  clockRunning,\n  cond,\n  divide,\n  eq,\n  event,\n  floor,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  or,\n  not,\n  round,\n  set,\n  spring,\n  startClock,\n  stopClock,\n  sub,\n  timing,\n} = Animated;\n\nconst TRUE = 1;\nconst FALSE = 0;\nconst NOOP = 0;\nconst UNSET = -1;\n\nconst DIRECTION_LEFT = 1;\nconst DIRECTION_RIGHT = -1;\n\nconst SWIPE_DISTANCE_MINIMUM = 20;\nconst SWIPE_DISTANCE_MULTIPLIER = 1 / 1.75;\n\nconst SWIPE_VELOCITY_THRESHOLD_DEFAULT = 800;\n\nconst SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nconst TIMING_CONFIG = {\n  duration: 200,\n  easing: Easing.out(Easing.cubic),\n};\n\nexport default class Pager<T extends Route> extends React.Component<Props<T>> {\n  static defaultProps = {\n    swipeVelocityThreshold: SWIPE_VELOCITY_THRESHOLD_DEFAULT,\n  };\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const {\n      navigationState,\n      layout,\n      swipeDistanceThreshold,\n      swipeVelocityThreshold,\n      springConfig,\n      timingConfig,\n    } = this.props;\n    const { index, routes } = navigationState;\n\n    if (\n      // Check for index in state to avoid unintended transition if component updates during swipe\n      (index !== prevProps.navigationState.index &&\n        index !== this.currentIndexValue) ||\n      // Check if the user updated the index correctly after an update\n      (typeof this.pendingIndexValue === 'number' &&\n        index !== this.pendingIndexValue)\n    ) {\n      // Index in user's state is different from the index being tracked\n      this.jumpToIndex(index);\n    }\n\n    // Reset the pending index\n    this.pendingIndexValue = undefined;\n\n    // Update our mappings of animated nodes when props change\n    if (prevProps.navigationState.routes.length !== routes.length) {\n      this.routesLength.setValue(routes.length);\n    }\n\n    if (prevProps.layout.width !== layout.width) {\n      this.progress.setValue(-index * layout.width);\n      this.layoutWidth.setValue(layout.width);\n    }\n\n    if (swipeDistanceThreshold != null) {\n      if (prevProps.swipeDistanceThreshold !== swipeDistanceThreshold) {\n        this.swipeDistanceThreshold.setValue(swipeDistanceThreshold);\n      }\n    } else {\n      if (prevProps.layout.width !== layout.width) {\n        this.swipeDistanceThreshold.setValue(\n          layout.width * SWIPE_DISTANCE_MULTIPLIER\n        );\n      }\n    }\n\n    if (prevProps.swipeVelocityThreshold !== swipeVelocityThreshold) {\n      this.swipeVelocityThreshold.setValue(\n        swipeVelocityThreshold != null\n          ? swipeVelocityThreshold\n          : SWIPE_VELOCITY_THRESHOLD_DEFAULT\n      );\n    }\n\n    if (prevProps.springConfig !== springConfig) {\n      this.springConfig.damping.setValue(\n        springConfig.damping !== undefined\n          ? springConfig.damping\n          : SPRING_CONFIG.damping\n      );\n\n      this.springConfig.mass.setValue(\n        springConfig.mass !== undefined ? springConfig.mass : SPRING_CONFIG.mass\n      );\n\n      this.springConfig.stiffness.setValue(\n        springConfig.stiffness !== undefined\n          ? springConfig.stiffness\n          : SPRING_CONFIG.stiffness\n      );\n\n      this.springConfig.restSpeedThreshold.setValue(\n        springConfig.restSpeedThreshold !== undefined\n          ? springConfig.restSpeedThreshold\n          : SPRING_CONFIG.restSpeedThreshold\n      );\n\n      this.springConfig.restDisplacementThreshold.setValue(\n        springConfig.restDisplacementThreshold !== undefined\n          ? springConfig.restDisplacementThreshold\n          : SPRING_CONFIG.restDisplacementThreshold\n      );\n    }\n\n    if (prevProps.timingConfig !== timingConfig) {\n      this.timingConfig.duration.setValue(\n        timingConfig.duration !== undefined\n          ? timingConfig.duration\n          : TIMING_CONFIG.duration\n      );\n    }\n  }\n\n  // Clock used for tab transition animations\n  private clock = new Clock();\n\n  // Current state of the gesture\n  private velocityX = new Value(0);\n  private gestureX = new Value(0);\n  private gestureState = new Value(State.UNDETERMINED);\n  private offsetX = new Value(0);\n\n  // Current progress of the page (translateX value)\n  private progress = new Value(\n    // Initial value is based on the index and page width\n    this.props.navigationState.index * this.props.layout.width * DIRECTION_RIGHT\n  );\n\n  // Initial index of the tabs\n  private index = new Value(this.props.navigationState.index);\n\n  // Next index of the tabs, updated for navigation from outside (tab press, state update)\n  private nextIndex: Animated.Value<number> = new Value(UNSET);\n\n  // Scene that was last entered\n  private lastEnteredIndex = new Value(this.props.navigationState.index);\n\n  // Whether the user is currently dragging the screen\n  private isSwiping: Animated.Value<Binary> = new Value(FALSE);\n\n  // Whether the update was due to swipe gesture\n  // This controls whether the transition will use a spring or timing animation\n  // Remember to set it before transition needs to occur\n  private isSwipeGesture: Animated.Value<Binary> = new Value(FALSE);\n\n  // Mappings to some prop values\n  // We use them in animation calculations, so we need live animated nodes\n  private routesLength = new Value(this.props.navigationState.routes.length);\n  private layoutWidth = new Value(this.props.layout.width);\n\n  // Threshold values to determine when to trigger a swipe gesture\n  private swipeDistanceThreshold = new Value(\n    this.props.swipeDistanceThreshold || 180\n  );\n  private swipeVelocityThreshold = new Value(this.props.swipeVelocityThreshold);\n\n  // The position value represent the position of the pager on a scale of 0 - routes.length-1\n  // It is calculated based on the translate value and layout width\n  // If we don't have the layout yet, we should return the current index\n  private position = cond(\n    this.layoutWidth,\n    divide(multiply(this.progress, -1), this.layoutWidth),\n    this.index\n  );\n\n  // Animation configuration\n  private springConfig = {\n    damping: new Value(\n      this.props.springConfig.damping !== undefined\n        ? this.props.springConfig.damping\n        : SPRING_CONFIG.damping\n    ),\n    mass: new Value(\n      this.props.springConfig.mass !== undefined\n        ? this.props.springConfig.mass\n        : SPRING_CONFIG.mass\n    ),\n    stiffness: new Value(\n      this.props.springConfig.stiffness !== undefined\n        ? this.props.springConfig.stiffness\n        : SPRING_CONFIG.stiffness\n    ),\n    restSpeedThreshold: new Value(\n      this.props.springConfig.restSpeedThreshold !== undefined\n        ? this.props.springConfig.restSpeedThreshold\n        : SPRING_CONFIG.restSpeedThreshold\n    ),\n    restDisplacementThreshold: new Value(\n      this.props.springConfig.restDisplacementThreshold !== undefined\n        ? this.props.springConfig.restDisplacementThreshold\n        : SPRING_CONFIG.restDisplacementThreshold\n    ),\n  };\n\n  private timingConfig = {\n    duration: new Value(\n      this.props.timingConfig.duration !== undefined\n        ? this.props.timingConfig.duration\n        : TIMING_CONFIG.duration\n    ),\n  };\n\n  // The reason for using this value instead of simply passing `this._velocity`\n  // into a spring animation is that we need to reverse it if we're using RTL mode.\n  // Also, it's not possible to pass multiplied value there, because\n  // value passed to STATE of spring (the first argument) has to be Animated.Value\n  // and it's not allowed to pass other nodes there. The result of multiplying is not an\n  // Animated.Value. So this value is being updated on each start of spring animation.\n  private initialVelocityForSpring = new Value(0);\n\n  // The current index change caused by the pager's animation\n  // The pager is used as a controlled component\n  // We need to keep track of the index to determine when to trigger animation\n  // The state will change at various points, we should only respond when we are out of sync\n  // This will ensure smoother animation and avoid weird glitches\n  private currentIndexValue = this.props.navigationState.index;\n\n  // The pending index value as result of state update caused by swipe gesture\n  // We need to set it when state changes from inside this component\n  // It also needs to be reset right after componentDidUpdate fires\n  private pendingIndexValue: number | undefined = undefined;\n\n  // Listeners for the entered screen\n  private enterListeners: Listener[] = [];\n\n  private jumpToIndex = (index: number) => {\n    // If the index changed, we need to trigger a tab switch\n    this.isSwipeGesture.setValue(FALSE);\n    this.nextIndex.setValue(index);\n  };\n\n  private jumpTo = (key: string) => {\n    const { navigationState } = this.props;\n\n    const index = navigationState.routes.findIndex(route => route.key === key);\n\n    // A tab switch might occur when we're in the middle of a transition\n    // In that case, the index might be same as before\n    // So we conditionally make the pager to update the position\n    if (navigationState.index === index) {\n      this.jumpToIndex(index);\n    } else {\n      this.props.onIndexChange(index);\n    }\n  };\n\n  private addListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter':\n        this.enterListeners.push(listener);\n        break;\n    }\n  };\n\n  private removeListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter': {\n        const index = this.enterListeners.indexOf(listener);\n\n        if (index > -1) {\n          this.enterListeners.splice(index, 1);\n        }\n\n        break;\n      }\n    }\n  };\n\n  private handleEnteredIndexChange = ([value]: readonly number[]) => {\n    const index = Math.max(\n      0,\n      Math.min(value, this.props.navigationState.routes.length - 1)\n    );\n\n    this.enterListeners.forEach(listener => listener(index));\n  };\n\n  private transitionTo = (index: Animated.Node<number>) => {\n    const toValue = new Value(0);\n    const frameTime = new Value(0);\n\n    const state = {\n      position: this.progress,\n      time: new Value(0),\n      finished: new Value(FALSE),\n    };\n\n    return block([\n      cond(clockRunning(this.clock), NOOP, [\n        // Animation wasn't running before\n        // Set the initial values and start the clock\n        set(toValue, multiply(index, this.layoutWidth, DIRECTION_RIGHT)),\n        set(frameTime, 0),\n        set(state.time, 0),\n        set(state.finished, FALSE),\n        set(this.index, index),\n        startClock(this.clock),\n      ]),\n      cond(\n        this.isSwipeGesture,\n        // Animate the values with a spring for swipe\n        [\n          cond(\n            not(clockRunning(this.clock)),\n            I18nManager.isRTL\n              ? set(this.initialVelocityForSpring, multiply(-1, this.velocityX))\n              : set(this.initialVelocityForSpring, this.velocityX)\n          ),\n          spring(\n            this.clock,\n            { ...state, velocity: this.initialVelocityForSpring },\n            { ...SPRING_CONFIG, ...this.springConfig, toValue }\n          ),\n        ],\n        // Otherwise use a timing animation for faster switching\n        timing(\n          this.clock,\n          { ...state, frameTime },\n          { ...TIMING_CONFIG, ...this.timingConfig, toValue }\n        )\n      ),\n      cond(state.finished, [\n        // Reset values\n        set(this.isSwipeGesture, FALSE),\n        set(this.gestureX, 0),\n        set(this.velocityX, 0),\n        // When the animation finishes, stop the clock\n        stopClock(this.clock),\n      ]),\n    ]);\n  };\n\n  private handleGestureEvent = event([\n    {\n      nativeEvent: {\n        translationX: this.gestureX,\n        velocityX: this.velocityX,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  private translateX = block([\n    onChange(\n      this.index,\n      call([this.index], ([value]) => {\n        this.currentIndexValue = value;\n\n        // Without this check, the pager can go to an infinite update <-> animate loop for sync updates\n        if (value !== this.props.navigationState.index) {\n          // If the index changed, and previous animation has finished, update state\n          this.props.onIndexChange(value);\n\n          this.pendingIndexValue = value;\n\n          // Force componentDidUpdate to fire, whether user does a setState or not\n          // This allows us to detect when the user drops the update and revert back\n          // It's necessary to make sure that the state stays in sync\n          this.forceUpdate();\n        }\n      })\n    ),\n    onChange(\n      this.position,\n      // Listen to updates in the position to detect when we enter a screen\n      // This is useful for things such as lazy loading when index change will fire too late\n      cond(\n        I18nManager.isRTL\n          ? lessThan(this.gestureX, 0)\n          : greaterThan(this.gestureX, 0),\n        // Based on the direction of the gesture, determine if we're entering the previous or next screen\n        cond(neq(floor(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, floor(this.position)),\n          call([floor(this.position)], this.handleEnteredIndexChange),\n        ]),\n        cond(neq(ceil(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, ceil(this.position)),\n          call([ceil(this.position)], this.handleEnteredIndexChange),\n        ])\n      )\n    ),\n    onChange(\n      this.isSwiping,\n      // Listen to updates for this value only when it changes\n      // Without `onChange`, this will fire even if the value didn't change\n      // We don't want to call the listeners if the value didn't change\n      call([this.isSwiping], ([value]: readonly Binary[]) => {\n        const { keyboardDismissMode, onSwipeStart, onSwipeEnd } = this.props;\n\n        if (value === TRUE) {\n          onSwipeStart && onSwipeStart();\n\n          if (keyboardDismissMode === 'on-drag') {\n            Keyboard.dismiss();\n          }\n        } else {\n          onSwipeEnd && onSwipeEnd();\n        }\n      })\n    ),\n    onChange(\n      this.nextIndex,\n      cond(neq(this.nextIndex, UNSET), [\n        // Stop any running animations\n        cond(clockRunning(this.clock), stopClock(this.clock)),\n        set(this.gestureX, 0),\n        // Update the index to trigger the transition\n        set(this.index, this.nextIndex),\n        set(this.nextIndex, UNSET),\n      ])\n    ),\n    cond(\n      eq(this.gestureState, State.ACTIVE),\n      [\n        cond(this.isSwiping, NOOP, [\n          // We weren't dragging before, set it to true\n          set(this.isSwiping, TRUE),\n          set(this.isSwipeGesture, TRUE),\n          // Also update the drag offset to the last progress\n          set(this.offsetX, this.progress),\n        ]),\n        // Update progress with previous offset + gesture distance\n        set(\n          this.progress,\n          I18nManager.isRTL\n            ? sub(this.offsetX, this.gestureX)\n            : add(this.offsetX, this.gestureX)\n        ),\n        // Stop animations while we're dragging\n        stopClock(this.clock),\n      ],\n      [\n        set(this.isSwiping, FALSE),\n        this.transitionTo(\n          cond(\n            and(\n              greaterThan(abs(this.gestureX), SWIPE_DISTANCE_MINIMUM),\n              or(\n                greaterThan(abs(this.gestureX), this.swipeDistanceThreshold),\n                greaterThan(abs(this.velocityX), this.swipeVelocityThreshold)\n              )\n            ),\n            // For swipe gesture, to calculate the index, determine direction and add to index\n            // When the user swipes towards the left, we transition to the next tab\n            // When the user swipes towards the right, we transition to the previous tab\n            round(\n              min(\n                max(\n                  0,\n                  sub(\n                    this.index,\n                    cond(\n                      greaterThan(\n                        // Gesture can be positive, or negative\n                        // Get absolute for comparision\n                        abs(this.gestureX),\n                        this.swipeDistanceThreshold\n                      ),\n                      // If gesture value exceeded the threshold, calculate direction from distance travelled\n                      cond(\n                        greaterThan(this.gestureX, 0),\n                        I18nManager.isRTL ? DIRECTION_RIGHT : DIRECTION_LEFT,\n                        I18nManager.isRTL ? DIRECTION_LEFT : DIRECTION_RIGHT\n                      ),\n                      // Otherwise calculate direction from the gesture velocity\n                      cond(\n                        greaterThan(this.velocityX, 0),\n                        I18nManager.isRTL ? DIRECTION_RIGHT : DIRECTION_LEFT,\n                        I18nManager.isRTL ? DIRECTION_LEFT : DIRECTION_RIGHT\n                      )\n                    )\n                  )\n                ),\n                sub(this.routesLength, 1)\n              )\n            ),\n            // Index didn't change/changed due to state update\n            this.index\n          )\n        ),\n      ]\n    ),\n    this.progress,\n  ]);\n\n  private getTranslateX = memoize(\n    (\n      layoutWidth: Animated.Node<number>,\n      routesLength: Animated.Node<number>,\n      translateX: Animated.Node<number>\n    ) =>\n      multiply(\n        // Make sure that the translation doesn't exceed the bounds to prevent overscrolling\n        min(\n          max(\n            multiply(layoutWidth, sub(routesLength, 1), DIRECTION_RIGHT),\n            translateX\n          ),\n          0\n        ),\n        I18nManager.isRTL ? -1 : 1\n      )\n  );\n\n  render() {\n    const {\n      layout,\n      navigationState,\n      swipeEnabled,\n      children,\n      removeClippedSubviews,\n      gestureHandlerProps,\n    } = this.props;\n\n    const translateX = this.getTranslateX(\n      this.layoutWidth,\n      this.routesLength,\n      this.translateX\n    );\n\n    return children({\n      position: this.position,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: children => (\n        <PanGestureHandler\n          enabled={layout.width !== 0 && swipeEnabled}\n          onGestureEvent={this.handleGestureEvent}\n          onHandlerStateChange={this.handleGestureEvent}\n          activeOffsetX={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          failOffsetY={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          {...gestureHandlerProps}\n        >\n          <Animated.View\n            removeClippedSubviews={removeClippedSubviews}\n            style={[\n              styles.container,\n              layout.width\n                ? {\n                    width: layout.width * navigationState.routes.length,\n                    transform: [{ translateX }] as any,\n                  }\n                : null,\n            ]}\n          >\n            {children}\n          </Animated.View>\n        </PanGestureHandler>\n      ),\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row',\n  },\n});\n"]}