{"version":3,"sources":["ScenesReducer.tsx"],"names":["shallowEqual","SCENE_KEY_PREFIX","compareKey","one","two","delta","length","compareScenes","index","key","areScenesShallowEqual","isStale","isActive","areRoutesShallowEqual","route","ScenesReducer","scenes","nextState","prevState","descriptors","forEach","scene","descriptor","prevScenes","Map","freshScenes","staleScenes","set","nextKeys","Set","nextRoutes","routes","console","warn","slice","has","Error","add","delete","prevRoutes","lastScene","find","nextScenes","mergeScene","nextScene","prevScene","get","push","sort","activeScenesCount","ii","some"],"mappings":"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","sourcesContent":["import shallowEqual from '../utils/shallowEqual';\nimport { Scene, Route, NavigationState, SceneDescriptor } from '../types';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one: string, two: string) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one: Scene, two: Scene) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one: Scene, two: Scene) {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one: Route, two: Route) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(\n  scenes: Scene[],\n  nextState: NavigationState,\n  prevState: NavigationState | null,\n  descriptors: { [key: string]: SceneDescriptor }\n) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn(\n      'StackRouter provided invalid state, index should always be the top route'\n    );\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene: Scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor,\n    };\n\n    if (nextKeys.has(key)) {\n      throw new Error(\n        `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n          'another route!'\n      );\n    }\n\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn(\n        'StackRouter provided invalid state, index should always be the top route'\n      );\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene\n        ? lastScene.descriptor\n        : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor,\n        });\n      }\n    });\n  }\n\n  const nextScenes: Scene[] = [];\n\n  const mergeScene = (nextScene: Scene) => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  if (activeScenesCount !== 1) {\n    throw new Error(\n      `There should always be only one scene active, not ${activeScenesCount}.`\n    );\n  }\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene, index) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"]}