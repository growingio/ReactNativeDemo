{"version":3,"sources":["Transitioner.tsx"],"names":["DefaultTransitionSpec","duration","easing","Easing","inOut","ease","timing","Animated","Transitioner","props","computeScenes","nextProps","nextScenes","state","scenes","navigation","descriptors","isTransitioning","filterStale","screenProps","setState","handleLayout","event","nativeEvent","layout","height","width","initWidth","initHeight","isMeasured","setValue","nextState","transitionProps","buildTransitionProps","handleTransitionEnd","isComponentMounted","prevTransitionProps","undefined","onTransitionEnd","result","Promise","queuedTransition","prevProps","startTransition","isTransitionRunning","Value","position","index","positionListener","addListener","removeListener","indexHasChanged","toValue","onTransitionStart","transitionUserSpec","configureTransition","transitionSpec","positionHasChanged","__getValue","start","requestAnimationFrame","styles","main","render","React","Component","scene","find","isSceneActive","Error","isSceneNotStale","isStale","filtered","filter","length","isActive","StyleSheet","create","flex"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  Easing,\n  StyleSheet,\n  View,\n  LayoutChangeEvent,\n} from 'react-native';\n\nimport NavigationScenesReducer from './ScenesReducer';\nimport {\n  NavigationProp,\n  Scene,\n  SceneDescriptor,\n  TransitionerLayout,\n  TransitionProps,\n} from '../types';\n\ntype TransitionSpec = {};\n\ntype Props = {\n  render: (\n    current: TransitionProps,\n    previous?: TransitionProps\n  ) => React.ReactNode;\n  configureTransition?: (\n    current: TransitionProps,\n    previous?: TransitionProps\n  ) => TransitionSpec;\n  onTransitionStart?: (\n    current: TransitionProps,\n    previous?: TransitionProps\n  ) => void | Promise<any>;\n  onTransitionEnd?: (\n    current: TransitionProps,\n    previous?: TransitionProps\n  ) => void | Promise<any>;\n  navigation: NavigationProp;\n  descriptors: { [key: string]: SceneDescriptor };\n  screenProps?: unknown;\n};\n\ntype State = {\n  layout: TransitionerLayout;\n  position: Animated.Value;\n  scenes: Scene[];\n  nextScenes?: Scene[];\n};\n\n// Used for all animations unless overriden\nconst DefaultTransitionSpec = {\n  duration: 250,\n  easing: Easing.inOut(Easing.ease),\n  timing: Animated.timing,\n};\n\nclass Transitioner extends React.Component<Props, State> {\n  private positionListener: string;\n\n  private prevTransitionProps: TransitionProps | undefined;\n  private transitionProps: TransitionProps;\n\n  private isComponentMounted: boolean;\n  private isTransitionRunning: boolean;\n  private queuedTransition: { prevProps: Props } | null;\n\n  constructor(props: Props) {\n    super(props);\n\n    // The initial layout isn't measured. Measured layout will be only available\n    // when the component is mounted.\n    const layout: TransitionerLayout = {\n      height: new Animated.Value(0),\n      initHeight: 0,\n      initWidth: 0,\n      isMeasured: false,\n      width: new Animated.Value(0),\n    };\n\n    const position = new Animated.Value(this.props.navigation.state.index);\n    this.positionListener = position.addListener((/* { value } */) => {\n      // This should work until we detach position from a view! so we have to be\n      // careful to not ever detach it, thus the gymnastics in _getPosition in\n      // StackViewLayout\n      // This should log each frame when releasing the gesture or when pressing\n      // the back button! If not, something has gone wrong with the animated\n      // value subscription\n      // console.log(value);\n    });\n\n    this.state = {\n      layout,\n      position,\n      scenes: NavigationScenesReducer(\n        [],\n        this.props.navigation.state,\n        null,\n        this.props.descriptors\n      ),\n    };\n\n    this.prevTransitionProps = undefined;\n    this.transitionProps = buildTransitionProps(props, this.state);\n\n    this.isComponentMounted = false;\n    this.isTransitionRunning = false;\n    this.queuedTransition = null;\n  }\n\n  componentDidMount() {\n    this.isComponentMounted = true;\n  }\n\n  componentWillUnmount() {\n    this.isComponentMounted = false;\n    this.positionListener &&\n      this.state.position.removeListener(this.positionListener);\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\n    if (this.isTransitionRunning) {\n      if (!this.queuedTransition) {\n        this.queuedTransition = { prevProps: this.props };\n      }\n      return;\n    }\n\n    this.startTransition(this.props, nextProps);\n  }\n\n  private computeScenes = (props: Props, nextProps: Props) => {\n    let nextScenes = NavigationScenesReducer(\n      this.state.scenes,\n      nextProps.navigation.state,\n      props.navigation.state,\n      nextProps.descriptors\n    );\n\n    if (!nextProps.navigation.state.isTransitioning) {\n      nextScenes = filterStale(nextScenes);\n    }\n\n    // Update nextScenes when we change screenProps\n    // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n    if (nextProps.screenProps !== this.props.screenProps) {\n      this.setState({ nextScenes });\n    }\n\n    if (nextScenes === this.state.scenes) {\n      return;\n    }\n\n    return nextScenes;\n  };\n\n  private startTransition(props: Props, nextProps: Props) {\n    const indexHasChanged =\n      props.navigation.state.index !== nextProps.navigation.state.index;\n    let nextScenes = this.computeScenes(props, nextProps);\n\n    if (!nextScenes) {\n      // prevTransitionProps are the same as transitionProps in this case\n      // because nothing changed\n      this.prevTransitionProps = this.transitionProps;\n\n      // Unsure if this is actually a good idea... Also related to\n      // https://github.com/react-navigation/react-navigation/issues/5247\n      // - the animation is interrupted before completion so this ensures\n      // that it is properly set to the final position before firing\n      // onTransitionEnd\n      this.state.position.setValue(props.navigation.state.index);\n\n      this.handleTransitionEnd();\n      return;\n    }\n\n    const nextState = {\n      ...this.state,\n      scenes: nextScenes,\n    };\n\n    // grab the position animated value\n    const { position } = nextState;\n\n    // determine where we are meant to transition to\n    const toValue = nextProps.navigation.state.index;\n\n    // compute transitionProps\n    this.prevTransitionProps = this.transitionProps;\n    this.transitionProps = buildTransitionProps(nextProps, nextState);\n    let { isTransitioning } = this.transitionProps.navigation.state;\n\n    // if the state isn't transitioning that is meant to signal that we should\n    // transition immediately to the new index. if the index hasn't changed, do\n    // the same thing here. it's not clear to me why we ever start a transition\n    // when the index hasn't changed, this requires further investigation.\n    if (!isTransitioning || !indexHasChanged) {\n      this.setState(nextState, async () => {\n        if (nextProps.onTransitionStart) {\n          const result = nextProps.onTransitionStart(\n            this.transitionProps,\n            this.prevTransitionProps\n          );\n          if (result instanceof Promise) {\n            // why do we bother awaiting the result here?\n            await result;\n          }\n        }\n        // jump immediately to the new value\n        indexHasChanged && position.setValue(toValue);\n        // end the transition\n        this.handleTransitionEnd();\n      });\n    } else if (isTransitioning) {\n      this.isTransitionRunning = true;\n      this.setState(nextState, async () => {\n        if (nextProps.onTransitionStart) {\n          const result = nextProps.onTransitionStart(\n            this.transitionProps,\n            this.prevTransitionProps\n          );\n\n          // Wait for the onTransitionStart to resolve if needed.\n          if (result instanceof Promise) {\n            await result;\n          }\n        }\n\n        // get the transition spec.\n        const transitionUserSpec = nextProps.configureTransition\n          ? nextProps.configureTransition(\n              this.transitionProps,\n              this.prevTransitionProps\n            )\n          : null;\n\n        const transitionSpec = {\n          ...DefaultTransitionSpec,\n          ...transitionUserSpec,\n        };\n\n        const { timing } = transitionSpec;\n        delete transitionSpec.timing;\n\n        // if swiped back, indexHasChanged == true && positionHasChanged == false\n        // @ts-ignore\n        const positionHasChanged = position.__getValue() !== toValue;\n        if (indexHasChanged && positionHasChanged) {\n          timing(position, {\n            ...transitionSpec,\n            toValue: nextProps.navigation.state.index,\n          }).start(() => {\n            // In case the animation is immediately interrupted for some reason,\n            // we move this to the next frame so that onTransitionStart can fire\n            // first (https://github.com/react-navigation/react-navigation/issues/5247)\n            requestAnimationFrame(this.handleTransitionEnd);\n          });\n        } else {\n          this.handleTransitionEnd();\n        }\n      });\n    }\n  }\n\n  render() {\n    return (\n      <View onLayout={this.handleLayout} style={styles.main}>\n        {this.props.render(this.transitionProps, this.prevTransitionProps)}\n      </View>\n    );\n  }\n\n  private handleLayout = (event: LayoutChangeEvent) => {\n    const { height, width } = event.nativeEvent.layout;\n    if (\n      this.state.layout.initWidth === width &&\n      this.state.layout.initHeight === height\n    ) {\n      return;\n    }\n    const layout: TransitionerLayout = {\n      ...this.state.layout,\n      initHeight: height,\n      initWidth: width,\n      isMeasured: true,\n    };\n\n    layout.height.setValue(height);\n    layout.width.setValue(width);\n\n    const nextState = {\n      ...this.state,\n      layout,\n    };\n\n    this.transitionProps = buildTransitionProps(this.props, nextState);\n    this.setState(nextState);\n  };\n\n  private handleTransitionEnd = () => {\n    if (!this.isComponentMounted) {\n      return;\n    }\n    const prevTransitionProps = this.prevTransitionProps;\n    this.prevTransitionProps = undefined;\n\n    const scenes = filterStale(this.state.scenes);\n\n    const nextState = {\n      ...this.state,\n      scenes,\n    };\n\n    this.transitionProps = buildTransitionProps(this.props, nextState);\n\n    this.setState(nextState, async () => {\n      if (this.props.onTransitionEnd) {\n        const result = this.props.onTransitionEnd(\n          this.transitionProps,\n          prevTransitionProps\n        );\n\n        if (result instanceof Promise) {\n          await result;\n        }\n      }\n\n      if (this.queuedTransition) {\n        let { prevProps } = this.queuedTransition;\n        this.queuedTransition = null;\n        this.startTransition(prevProps, this.props);\n      } else {\n        this.isTransitionRunning = false;\n      }\n    });\n  };\n}\n\nfunction buildTransitionProps(props: Props, state: State): TransitionProps {\n  const { navigation } = props;\n\n  const { layout, position, scenes } = state;\n\n  const scene = scenes.find(isSceneActive);\n\n  if (!scene) {\n    throw new Error('Could not find active scene');\n  }\n\n  return {\n    layout,\n    navigation,\n    position,\n    scenes,\n    scene,\n    index: scene.index,\n  };\n}\n\nfunction isSceneNotStale(scene: Scene) {\n  return !scene.isStale;\n}\n\nfunction filterStale(scenes: Scene[]) {\n  const filtered = scenes.filter(isSceneNotStale);\n  if (filtered.length === scenes.length) {\n    return scenes;\n  }\n  return filtered;\n}\n\nfunction isSceneActive(scene: Scene) {\n  return scene.isActive;\n}\n\nconst styles = StyleSheet.create({\n  main: {\n    flex: 1,\n  },\n});\n\nexport default Transitioner;\n"]}